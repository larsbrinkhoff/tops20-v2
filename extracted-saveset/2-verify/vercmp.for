C	VERCMP.FOR	4/12/76
C
C A FORTRAN PROGRAM WHICH COMPARES INFORMATION IN TWO
C FILES TO DETERMINE WHETHER SPECIFIC FILES EXIST, AND
C WHETHER THE VERSION NUMBERS OF THESE PROGRAMS IN THE
C DISTRIBUTED CUSTOMER SYSTEM MATCH THOSE OF THE CONTROL
C DATA FILE.
C
C NOTE THAT THE LARGEST POSSIBLE VERSION NUMBER IS:
C
C		777BK(777777)-7
C
C
C FORMAT OF CONTROL DATA FILE (THE FILE WHICH CONTAINS THE FILE NAMES
C  AND VERSION NUMBERS WHICH SHOULD BE PRESENT):
C  UPTO 200 22-CHARACTER LINES OF --
C
C	[NAME], VERSION IS [VERSION][CR]
C
C  WHERE [NAME] IS THE FILE NAME (UPTO 15 CHARACTERS) AND IS TERMINATED
C  BY A COMMA.  THE WORDS "VERSION IS " THEN APPEAR, AND FINALLY THE
C  THE VERSION NUMBER ITSELF, UP TO 15 CHARACTERS.

C  EACH OF THESE LINES IS GENERATED BY THE EXEC IN RESPONSE TO THE
C  COMMANDS:
C
C	@GET [FILE]
C	@INFORMATION (ABOUT) VERSION
C
C  THE LINES ARE THEN EXTRACTED FROM A BATCH LOG FILE BY MEANS OF 
C  ANOTHER BATCH CONTROL FILE WHICH USES "EDIT" TO DO THE WORK.
C  WHEN THE CONTROL FILE IS READ BY THIS PROGRAM IT IS REFORMATTED WITHIN
C  A TWO DIMENSIONAL ARRAY AS DESCRIBED BELOW.
C
C
C
C COLUMN #	CONTENTS OF FIELD
C
C 1-15		FIELD 1.	ASCII FILE NAME
C 16			BLANK
C 17-31		FIELD 2.	ASCII VERSION NUMBER 
C				 WHICH SHOULD BE PRESENT
C
C THE FOLLOWING FIELDS ARE APPENDED TO EACH LINE AFTER FURTHER
C  PROCESSING BY THIS PROGRAM.
C
C 32			BLANK
C 33-47		FIELD 3.	VERSION NUMBER OF DISTRIBUTED SOFTWARE
C 48			BLANK
C 49-68		FIELD 4.	20-CHARACTER MESSAGE: ONE OF THE FOLLOWING:
C 		 CHECK OK
C 		 VER. NO. MISMATCH
C 		 PROGRAM MISSING	(THIS MESSAGE IS PLACED IN EVERY
C					LINE PRIOR TO THE READING OF
C					VERSIO.TXT.)
C 		 UNEXPECTED FILE
C		 NO VERS. #
C
C IN CORE THIS FILE IS REPRESENTED AS AN ARRAY OF 200 LINES
C  OF 68 CHARACTERS (PACKED ONE PER WORD) EACH.

C  INTEGER AND ARRAY DECLARATIONS.

	INTEGER CONTRL(68,200),VERSIO(72),MSG1(20),MSG2(20),MSG3(20)
	INTEGER PNSTRT,PSIZE,COMMA(1),ONE,MSG4(20),VERFLG
	INTEGER VERSIS(11),ELEVEN(1),CON72(1),MSG5(20),SPACE(1)
	INTEGER IMATCH,IFLD4,K,KFOUND,NEXT,IFLD3,KTEMP,LSIZE,LSTART
	INTEGER ISTART,IFLD2,J,ILAST,IFLD1,KSTART,NCONTR,I,IFLD5
	INTEGER KLAST,ITEMP

C  CONSTANTS

	DATA SPACE(1)/' '/
	DATA ELEVEN(1)/11/
	DATA CON72(1)/72/
	DATA COMMA(1)/','/
	DATA ONE/1/
	DATA (VERSIS(I),I=1,11,1)
	1  /'v','e','r','s','i','o','n',' ','i','s',' '/

C FIELD DEFINITIONS

	DATA IFLD1,IFLD2,IFLD3,IFLD4,IFLD5
	1  /1,17,33,49,68/

C MESSAGES

	DATA (MSG1(I),I=1,20,1)
	1  /'C','H','E','C','K',' ','O','K',12*' '/
	DATA (MSG2(I),I=1,20,1)
	1  /'V','E','R','.',' ','N','O','.',' ','M','I',
	2  'S','M','A','T','C','H',' ',' ',' '/
	DATA (MSG3(I),I=1,20,1)
	1  /'P','R','O','G','R','A','M',' ','M','I','S','S',
	2  'I','N','G',5*' '/
	DATA (MSG4(I),I=1,20,1)
	1  /'U','N','E','X','P','E','C','T','E','D',' ',
	2  'F','I','L','E',5*' '/
	DATA (MSG5(I),I=1,20,1)
	1 /'N','O',' ','V','E','R','S','.',' ','#',10*' '/


C PROGRAM STARTS HERE.

	OPEN (UNIT=20,DEVICE='DSK',ACCESS='SEQIN',MODE='ASCII',
	1 FILE='CONTRL.TXT')
	OPEN (UNIT=21,DEVICE='DSK',ACCESS='SEQIN',MODE='ASCII',
	1 FILE='VERSIO.TXT')
	OPEN (UNIT=22,DEVICE='DSK',ACCESS='APPEND',MODE='ASCII',
	1 DISPOSE='SAVE',FILE='ERRORS.LOG')

C	FIRST, READ IN THE ENTIRE CONTROL FILE AND
C	 RESTRUCTURE EACH LINE TO CONFORM TO THE FORMAT SPECIFIED ABOVE.
C	 FILL IN RIGHT HALF OF EACH LINE WITH MESSAGE 3 (DEFAULT).

	DO 100 I=1,200,1
		READ (20,1000,END=101)(CONTRL(J,I),J=1,IFLD5,1)

C		REFORMAT THE LINE AS FOLLOWS:
C		 FIRST ISOLATE THE PROGRAM OR FILE NAME (DELIMITED BY A COMMA)

		CALL SEARCH(COMMA,1,CONTRL(1,I),1,IFLD5,
	1	 KSTART,KLAST,KFOUND)
		IF (KFOUND.EQ.1)GOTO 10001

C			COMMA HAS NOT BEEN FOUND.  BLANK OUT THE REST OF THE LINE.

			DO 10002 K=IFLD2,IFLD5,1
				CONTRL(K,I)=' '
10002			CONTINUE
			GOTO 10004

C		COMMA HAS BEEN FOUND.  BLANK IT OUT AND FIND THE VERSION NUMBER.
C		 ALSO SAVE POINTER TO THE COMMA IN KTEMP.

10001		KTEMP=KSTART
		CONTRL(KSTART,I)=' '
		ISTART=KSTART+2
		CALL SEARCH(VERSIS,11,CONTRL(1,I),ISTART,IFLD5,
	1	 KSTART,KLAST,KFOUND)

C		IF THERE WAS A COMMA BUT NO "VERSION IS ", BLANK OUT THE REST
C		 OF THE LINE.

		IF (KFOUND.EQ.1) GOTO 10005
			DO 10006 K=KTEMP,IFLD5,1
				CONTRL(K,I)=' '
10006			CONTINUE
			GOTO 10004

C		VERSION NUMBER HAS BEEN LOCATED.  PUT IT ASIDE FOR A MOMENT.

10005		ISTART=KLAST+1
		CALL MOVE(CONTRL(ISTART,I),VERSIO,15)

C		NOW CLEAR REST OF LINE AND THEN RESTORE VERSION NUMBER.

		DO 10003 K=KTEMP,IFLD5,1
			CONTRL(K,I)=' '
10003		CONTINUE
		CALL MOVE(VERSIO,CONTRL(IFLD2,I),15)

C		NOW PUT IN THE DEFAULT MESSAGE.

10004		CALL MOVE(MSG3,CONTRL(IFLD4,I),20)
100	CONTINUE

C	AT END OF FILE, SAVE COUNT OF NUMBER OF LINES READ.
C	 "NEXT" POINTS TO NEXT AVAILABLE LINE FOR EXTRA MESSAGES.

101	NCONTR=I-1
	NEXT=NCONTR+1

C	 READ NEXT LINE FROM CUSTOMER LIST OF VERSION NOS.
C	 NOTE-- THESE WERE OBTAINED FROM THE .LOG FILE OF
C	 VERIFY.BAT

107	CONTINUE
	READ (21,1004,END=108)(VERSIO(I),I=1,72,1)

C	FIND COMMA DELIMITER

	ISTART=1
	ILAST=72
	CALL SEARCH(COMMA,ONE,VERSIO,ISTART,ILAST,KSTART,
	1 KLAST,KFOUND)

C	IF SEARCH SUCCESSFUL, WE KNOW HOW BIG THE PROGRAM NAME IS.
C	 IF NOT SUCCESSFUL, THERE WAS NO COMMA.  THEREFORE THIS
C	 PROGRAM OR FILE HAD NO VERSION #.  SO SET VERFLG ACCORDINGLY
C	 AND SET THE START AND THE LENGTH OF THE FILE NAME 
C	 TO THE SIZE OF THE STRING DELIMITED BY 1 AND THE FIRST SPACE.

	VERFLG=KFOUND
	IF (VERFLG.EQ.1) GOTO 1071
		CALL SEARCH(SPACE,1,VERSIO,1,72,KSTART,KLAST,KFOUND)

C		IF NO SPACE IS FOUND, SET SIZE OF NAME TO WHAT IS
C		 ALLOWED IN THE OUTPUT FORMAT.

		IF (KFOUND.EQ.0) KLAST=IFLD2-2
1071	CONTINUE

C	IT'S NOW POSSIBLE TO SAVE THE STARTING
C	 POSITION AND SIZE OF THE FILE NAME IN VERSIO. IT NOW
C	 BEGINS THE NEW SEARCH STRING.

	PNSTRT=1
	PSIZE=KLAST-1

C	NEXT FIND THE SAME PROGRAM NAME IN THE CONTROL FILE.

	DO 110 IMATCH=1,NCONTR,1

C		FOR THIS PROGRAM NAME, FIRST GET ITS SIZE.

		CALL SEARCH(SPACE,1,CONTRL(1,IMATCH),1,IFLD5,
	1	 KSTART,KLAST,KFOUND)

C		THERE SHOULD HAVE BEEN A TERMINATING SPACE.  IF
C		 NOT, GO TO NEXT ITERATION OF LOOP.

		IF (KFOUND.NE.1) GOTO 110

C		IF A COMMA WAS FOUND, CHECK THAT THE TWO NAMES
C		 ARE THE SAME SIZE.  OTHERWISE THEY ARE UNEQUAL,
C		 SO GO TO NEXT ITERATION OF LOOP.

		IF ((KLAST-1).NE.PSIZE) GOTO 110
		CALL SEARCH(VERSIO(1),PSIZE,CONTRL(1,IMATCH),ONE,
	1	 IFLD5,KSTART,KLAST,KFOUND)
		IF(KFOUND.EQ.1) GOTO 104
110	CONTINUE

C	FALL-THROUGH MEANS THERE IS A DISTRIBUTED FILE NOT FOUND
C	 IN THE CONTROL FILE.  SO WE PUT MESSAGE 4
C	 INTO THE CONTROL FILE.

	CALL MOVE(MSG4,CONTRL(IFLD4,NEXT),20)
	CALL MOVE(VERSIO(1),CONTRL(IFLD1,NEXT),PSIZE)
	NEXT=NEXT+1
	GOTO 107

C	FILE NAME HAS BEEN FOUND IN THE CONTROL FILE -- THERE ARE
C	 NOW A FEW CASES TO TEST FOR:  FIRST, WAS THERE A VERSION
C	 NUMBER IN VERSIO?  JUMP IF NOT AND TREAT IT AS IF THE 
C	 VERSION NUMBER WAS ALL BLANKS, SINCE THIS MAY BE OK.

104	IF (VERFLG.EQ.0) GOTO 10410

C	IF THERE WAS A VERSION #, FIND IT IN VERSIO.

	CALL SEARCH(VERSIS,ELEVEN,VERSIO,ONE,CON72,
	1  KSTART,KLAST,KFOUND)

C	UNEXPECTED ERROR IF "VERSION IS " NOT FOUND.

	IF(KFOUND.EQ.0) GOTO 106

C	VERSION # STARTS AT (KLAST+1)

	LSTART=KLAST+1
	LSIZE=15

C	MOVE VERSION # FROM VERSIO INTO CONTROL LINE.

	CALL MOVE(VERSIO(LSTART),CONTRL(IFLD3,IMATCH),LSIZE)

C	COMPARE VERSION #'S

10410	CALL SEARCH(CONTRL(IFLD3,IMATCH),15,CONTRL(IFLD2,IMATCH),
	1  1,15,KSTART,KLAST,KFOUND)
	IF(KFOUND.NE.1) GOTO 10411

C	IF VERSION #'S MATCH, PUT IN MESSAGE 1.

	CALL MOVE(MSG1,CONTRL(IFLD4,IMATCH),20)

C	LOOP BACK FOR NEXT LINE FROM VERSIO.

	GOTO 107

C	UNEXPECTED CONDITION.  WRITE OUT ERROR LINE.

106	WRITE (22,1003)(VERSIO(I),I=1,72,1)
	GOTO 107

C	VERSION #'S DON'T MATCH. MOVE IN ERROR MESSAGE.

10411	CALL MOVE(MSG2,CONTRL(IFLD4,IMATCH),20)
	GOTO 107

C	WRITE OUT CONTROL FILE WITH ALL THE COMMENTS IMBEDDED IN IT

108	ITEMP=NEXT-1
	WRITE (22,1001)((CONTRL(I,J),I=1,IFLD5,1),J=1,ITEMP,1)
	WRITE (22,1002)
	CLOSE (UNIT=22,DEVICE='DSK',ACCESS='APPEND',MODE='ASCII',
	1 DISPOSE='SAVE',FILE='ERRORS.LOG')
	STOP

1000	FORMAT (68A1)
1001	FORMAT(' ',/,
	1  ' ++++	SEARCH.FOR MESSAGE			++++',/,
	2  ' ++++	COMPARISON OF VERSION NUMBERS		++++',/,
	3  ' ++++						++++',/,
	4  ' PROGRAM NAME    SHOULD BE       VERSION IS',/,
	6  ' ',/,(' ',68A1))
1002	FORMAT(' ++++	END OF SEARCH.FOR MESSAGE		++++',/)
1003	FORMAT(/,' ++++	SEARCH.FOR ERROR			++++',/,
	1 ' ++++	THE FOLLOWING UNEXPECTED		++++',/,
	2 ' ++++	RECORD WAS FOUND IN VERSIO.TXT:		++++',/,
	3 ' ',72A1,/,
	4 ' ++++	END OF SEARCH.FOR ERROR			++++',/)
1004	FORMAT(72A1)
	END

C MOVE
C SUBROUTINE MOVES WORDS FROM FROM ONE ARRAY INTO ANOTHER.
C MAXIMUM MOVE OF 72 WORDS.
C
C	CALL MOVE(SOURCE,DEST,NCHAR)
C
	SUBROUTINE MOVE(SOURCE,DEST,NCHAR)
	INTEGER SOURCE(NCHAR),DEST(NCHAR),NCHAR

	DO 100 I=1,NCHAR,1
		DEST(I)=SOURCE(I)
100	CONTINUE
	RETURN
	END



C	SEARCH
C
C A SUBPROGRAM WHICH SEARCHES A STRING FOR A SUBSTRING.
C  CALLED AS FOLLOWS:
C
C CALL SEARCH (SUBSTR,LSUBST,AREA,ISTART,ILAST
C	,KSTART,KLAST,KFOUND)
C
C INPUTS:
C
C SUBSTR	AN ARRAY OF WORDS, WITH CHARACTERS
C		LEFT JUSTIFIED ONE PER WORD, CONTAINING
C		THE SUBSTRING TO SEARCH FOR
C
C LSUBST	SIZE OF SUBSTR IN WORDS ( AND THEREFORE
C		CHARACTERS)
C
C AREA		AN ARRAY OF SIMILAR FORMAT TO SUBSTR, 
C		CONTAINING THE STRING TO BE SEARCHED
C
C ISTART	POINTER INTO AREA -- FIRST CHARACTER TO
C		SEARCH
C
C ILAST		POINTER INTO AREA -- LAST CHARACTER TO 
C		SEARCH
C
C
C OUTPUTS:
C
C KSTART	POINTER INTO AREA -- START OF FOUND STRING
C
C KLAST		POINTER INTO AREA -- LAST CHARACTER OF
C		FOUND STRING
C
C KFOUND	=1	SEARCH WAS SUCCESSFUL
C		=0	SEARCH WAS UNSUCCESSFUL
C

	SUBROUTINE SEARCH (SUBSTR,LSUBST,AREA,ISTART,ILAST
	1,KSTART,KLAST,KFOUND)

	INTEGER AREA(100),SUBSTR(100),LSUBST,ISTART,ILAST,KSTART
	INTEGER KLAST,KFOUND

	LFOUND=0
	KFOUND=0
	DO 2000 I=ISTART,ILAST,1

C		COMPARE THE FIRST CHARACTER IN THE SUBSTRING WITH
C		THE CURRENT CHARACTER IN AREA.
C		IF SUCCESSFUL THIS IS A POSSIBLE PLACE TO
C		COMPARE FOR ENTIRE MATCH, SO CALL COMPAR.

		IF (SUBSTR(1).EQ.AREA(I)) 
	1		CALL COMPAR(SUBSTR,LSUBST,AREA,
	2		 I,ILAST,KLAST,LFOUND)
		IF (LFOUND.EQ.1) GOTO 1000

C		IF NOT SUCCESSFUL, THE DO LOOP CYCLES AROUND TO DO
C		A COMAPRISON OF THE FIRST CHAR. IN SUBSTR
C		WITH ANOTHER IN "AREA".

2000	CONTINUE

C	IF LOOP FALLS THROUGH THE SEARCH WAS UNSUCCESSFUL.

	RETURN

C	SET UP A SUCCESSFUL RETURN

1000	KSTART=I
	KFOUND=LFOUND
	RETURN
	END


C
C COMPAR
C
C A SUBPROGRAM WHICH COMPARES TWO STRINGS AND RETURNS
C SUCCESS IF THEY AR EQUAL.  CALLLED AS FOLLOWS:
C
C CALL COMPAR (SUBSTR,LSUBST,AREA,I,ILAST,KLAST,LFOUND)
C
C PARAMETERS ARE AS DEFINED FOR SEARCH (ABOVE), PLUS:
C
C I		POINTER INTO AREA -- FIRST CHARACTER
C		TO SEARCH
C
C LFOUND	=1	COMPARISON WAS SUCCESSFUL
C		=0	COMPARISON WAS UNSUCCESSFUL
C
C INPUTS: SUBSTR,LSUBST,AREA,I
C OUTPUTS: KLAST, LFOUND

	SUBROUTINE COMPAR 	(SUBSTR,LSUBST,AREA,I,ILAST
	1			,KLAST,LFOUND)

	INTEGER AREA(100),SUBSTR(100),LSUBST,ILAST,KSTART
	INTEGER KLAST,LFOUND

	J1=1
4000	DO 1000 J=I,ILAST,1
		IF (SUBSTR(J1).NE.AREA(J)) GO TO 2000
		J1=J1+1
		IF (J1.GT.LSUBST) GO TO 3000
1000	CONTINUE

C	IF LOOP FALLS THROUGH, ALL CHARACTERS IN AREA MATCHED
C	 THOSE IN SUBSTR, BUT AREA RAN OUT FIRST, SO IT'S 
C	 NO MATCH.

2000	RETURN

C	SUCCESSFUL MATCH.  PREPARE FOR RETURN

3000	KLAST=J
	LFOUND=1
	RETURN

	END

C TRACE

	SUBROUTINE TRACE(ISTMNT,A,B,I,J,K,L,M)
	INTEGER A(60),B(60),I,J,K,L,M
	TYPE 100,ISTMNT,(A(J1),J1=1,60,1),(B(J2),J2=1,60,1),I,J,K,L,M
100	FORMAT(' AT STATEMENT #',I5,/' ',60A1,/' '60A1,/' ',5I10,/,/)
	RETURN
	END

